

<!doctype html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<meta charset="utf-8">
<title>Counting Crosswords, Part 1 &#8211; Akshay's Blog</title>
<meta name="description" content="An incredibly useless but very fun side project.">
<meta name="keywords" content="">

<!-- DSLs for various open graph languages -->
<meta property="og:locale" content="en_US">
<meta property="og:title" content="Counting Crosswords, Part 1 &#8211; Akshay's Blog">
<meta property="og:description" content="An incredibly useless but very fun side project.">
<meta property="og:url" content="http://localhost:4000/articles/counting-crosswords">
<meta property="og:site_name" content="Akshay's Blog">

<meta property="og:image" content="crossword-header.jpg">





<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Akshay's Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Type -->
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Crimson+Text:400,400italic,700,700italic" rel='stylesheet' type='text/css' />
<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="http://localhost:4000/assets/css/entypo.css" media="all">

<!-- Katex -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

<!-- In order to use Calendas Plus, you must first purchase it. Then, create a font-face package using FontSquirrel.
<link rel='stylesheet' href='http://localhost:4000/assets/cal.css' media='all' />
-->



<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/i.css">

<!-- Fresh Squeezed jQuery -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">

<div id="bump">
  <body class="">
    <header class="site-header darken">
      <div class="wrap">
        <hgroup>
          <h1><a href="http://localhost:4000">Akshay's Blog</a></h1>
        </hgroup>
        <a href="#nav" class="menu"><span class='icons'>☰</span></a>
        <nav role="navigation">
          <ul>
            <li>
              <a href="http://localhost:4000" title="Akshay's Blog">Home</a>
            </li>

            <li>
              <a href="/" title="Akshay's Blog">Akshay's Website</a>
            </li>
          </ul>
        </nav>
      </div>
    </header>


<section class="article">

  <div class="overlay overlay-lighter"></div>
  <div class="featured-image" style="background-image: url(http://localhost:4000/images/crossword-header.jpg)"></div>



      <article class="wrap post">
        <header class="post-header">
          <hgroup>
            <h1>Counting Crosswords, Part 1</h1>
            <p class="date">Jul 03, 2020</p>
            <p class="intro">An incredibly useless but very fun side project.</p>
          </hgroup>
        </header>

        <p>Last year, some friends and I got really into crossword puzzles and set out to construct a puzzle for the New York Times. I can’t get into details, but the puzzle idea required finding a crossword grid that satisfied a strict set of constraints. The search for this grid turned into an unnecessarily-complicated-but-really-fun coding project with some cool extensions. It’s been a year but I’ve been really bored during quarantine, so figured I might as well write it up!</p>

<h2 id="what-defines-a-valid-crossword-grid">What defines a valid crossword grid?</h2>

<p>A New York Times crossword puzzle typically satisfies the following conditions:</p>

<ol>
  <li>The white squares are fully connected.</li>
  <li>It is rotationally symmetric. This means the first row should be the reverse of the last row, the second row should be the reverse of the second-to-last row, etc. And the middle row is a palindrome, i.e. the reverse of itself.</li>
  <li>Every square must be in both a down and an across answer, and every answer must be at least three letters long.</li>
</ol>

<p>For example, the following grid is invalid because the white squares aren’t fully connected:</p>

<p><img src="/blog/images/cross1.png" style="width:min(100%, 400px)" /></p>

<p>The following grid is connected, but it isn’t rotationally symmetric:</p>

<p><img src="/blog/images/cross3.png" style="width:min(100%, 400px)" /></p>

<p>And the following is connected and rotationally symmetric, but has one and two-letter answers (like 37-Across and 57-Down):</p>

<p><img src="/blog/images/cross2.png" style="width:min(100%, 400px)" /></p>

<p>The following grid satisfies all the conditions:</p>

<p><img src="/blog/images/cross4.png" style="width:min(100%, 400px)" /></p>

<p>The New York Times usually runs 15x15 puzzles on weekdays and 21x21 puzzles on weekends. Since we wanted to write a weekday puzzle, we focused on 15x15 grids. Note that even though we’re working with a fixed-size grid, we can still express algorithmic complexity in terms of \(n\), where \(n\) is the width of the grid.</p>

<h2 id="generating-crossword-puzzles">Generating Crossword Puzzles</h2>

<p>Alright, so we needed to generate valid 15x15 crossword grids and check a set of special conditions. It turns out these conditions were extremely rare, so performance was extremely important. In this section, I’ll go through different iterations of the algorithm, describing the optimizations that eventually brought us to an acceptable state. This isn’t exactly the order in which we arrived at the solution, but it’s close.</p>

<h3 id="take-1-python-and-chill">Take 1: Python and Chill</h3>

<p>We started off with a Python program that generated grids one square at a time. The pseudocode was something like this:</p>

<ol>
  <li>Represent each square using a boolean: <code class="language-plaintext highlighter-rouge">True</code> is black, <code class="language-plaintext highlighter-rouge">False</code> is white. Rather than store a two-dimensional 15x15 array, we concatenate the rows and represent each grid as a length-225 array.</li>
  <li>Recursively generate rotationally symmetric grids by filling in the first \(113 = \lceil 225/2 \rceil\) values with every combination of <code class="language-plaintext highlighter-rouge">True</code> and <code class="language-plaintext highlighter-rouge">False</code>. Set the remaining 112 values to the reverse of the first 112.</li>
  <li>For every grid, check the following conditions:
    <ul>
      <li>Check the three-letter minimum. In other words, a consecutive run of <code class="language-plaintext highlighter-rouge">False</code> values in any row or column must have length at least 3.</li>
      <li>Run a depth-first search on the white squares to ensure connectedness.</li>
      <li>Also check some “obvious” conditions: for example, the grid can’t have all-black rows or columns (otherwise it wouldn’t really be a 15x15 grid).</li>
    </ul>
  </li>
  <li>If everything looks good, check the special conditions.</li>
</ol>

<p>Of course, we weren’t trying to generate every possible 15x15 grid: just enough that we’d run into one that satisfied all the conditions. However, we were generating these grids so naively that a very, very small percentage of generated grids even made it to Step 4–perhaps one or two every minute. Of the grids that passed Step 4, we couldn’t find any that <em>really</em> worked: they were too sparse, or it’d be too hard to fill them with English words.</p>

<p>To tally things up:</p>

<ul>
  <li>This algorithm generates \(O(2^{n^2/2})\) candidate grids.</li>
  <li>Checking all the conditions (DFS, clue-length, all-black, etc.) takes \(O(n^2)\) time.</li>
  <li>Each grid takes \(O(n^2)\) space.</li>
</ul>

<p>To get this to work, we needed to take a smarter approach.</p>

<h3 id="take-2-one-row-at-a-time">Take 2: One Row at a Time</h3>

<p>Generating grids square by square was doomed to fail because the conditions depend on the relationship between squares–it made more sense to think in terms of rows. This way, we could eliminate invalid rows from the get-go. In fact, of the \(2^{15} = 32,768\) possible rows, <strong>less than 800</strong> satisfy the three-letter minimum!</p>

<p>I don’t know the exact solution, but it’s safe to say the number of valid rows is \(O(c^n)\) for some value of \(c &lt; 2\). I computed this for \(n = 5, 6, 7, \dots 20\) (see <a href="http://oeis.org/A130578">A130578</a>) and the ratio between consecutive terms indicates \(c \approx 1.6\).</p>

<p>(We also pruned rows that weren’t practically feasible, for example those with more than four black squares in a row. This reduces \(c\) even more.)</p>

<p>So now our algorithm looked like this:</p>

<ol>
  <li>Precompute all valid rows. As a special case, also precompute valid palindromic rows to account for the middle row. This takes \(O(2^n)\) time, but it’s a one-time thing so no worries.</li>
  <li>Fill in the first 8 rows of the crossword, and set the last 7 rows to the reverse of the first 7.</li>
  <li>Check vertical clue lengths, run the DFS check, and check special conditions.</li>
</ol>

<p>Now we’re looking at something like \(O((1.6^n)^{n/2}) = O(1.6^{n^2/2})\) candidate grids. Decreasing the base of the exponent is a huge improvement.</p>

<h3 id="take-3-considering-columns">Take 3: Considering Columns</h3>

<p>We could improve this algorithm by only adding rows that satisfy the three-letter minimum <strong>vertically</strong>. Because the middle three rows are so constrained, it helps to start from the middle row then move towards the edge. Recall that the 8th row is a palindrome, and the 7th and 9th rows are reverses of each other.</p>

<p>For example, the following isn’t allowed:</p>

<p><img src="/blog/images/rows1.png" style="width:min(100%, 500px)" /></p>

<p>But this is:</p>

<p><img src="/blog/images/rows2.png" style="width:min(100%, 500px)" /></p>

<p>With that in mind, here’s the new algorithm:</p>

<ol>
  <li>Precompute valid rows.</li>
  <li>For every possible 8th row, find all valid 7th rows.</li>
  <li>For the 6th row, only consider rows that satisfy the three-letter minimum with rows 7 through 9. Continue this until the edge of the grid. Note that the first three rows have special restrictions because they’re near the edge.</li>
  <li>Do the DFS check.</li>
  <li>Check special conditions.</li>
</ol>

<p>I’ve lost track of how many grids make it to Step 4, but it’s probably \(O(c^{n^2/2})\) for an even smaller value of \(c\). However, calculating the next row is an inefficient operation: we need to iterate through all valid rows, and do an \(O(n)\) check for each one. It’d be nice if we could precompute things.</p>

<h3 id="take-4-going-a-bit-crazy">Take 4: “Go”ing a “Bit” Crazy</h3>

<p>We were beginning to reach the limits of this grid representation: boolean arrays weren’t fun to work with, and we couldn’t precompute too much because it’s so space-inefficient.</p>

<p>The solution: instead of booleans, treat each square as a bit! We can fit each row in a 16-bit integer, so our new grid representation is simply an array of 15 <code class="language-plaintext highlighter-rouge">uint16</code> values. How nice. To implement this, a measly Python program wasn’t going to cut it. We needed to take things to the next level.</p>

<p>(Okay, in retrospect I’m not convinced that we <em>needed</em> to: like, if I ran the program for long enough I’m sure we would have found a grid that worked. But the project had transcended this one crossword puzzle, and had become something much deeper. Or I was going insane.)</p>

<p>Anyways, I rewrote the whole thing in Go. It’d been a few years, and I wanted to brush up. Go also made it easier to implement Grid Representation 2.0.</p>

<p>Now, we can precompute valid rows as a list of <code class="language-plaintext highlighter-rouge">uint16</code> values. We can also compute a map <code class="language-plaintext highlighter-rouge">reverse</code> where <code class="language-plaintext highlighter-rouge">reverse[x]</code> stores the bitwise reverse of <code class="language-plaintext highlighter-rouge">x</code>: this makes it easier to fill the bottom half of the grid.</p>

<p>So given three rows <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">c</code>, how do we calculate all possible next rows <code class="language-plaintext highlighter-rouge">x</code>? It might help to look at a diagram (<code class="language-plaintext highlighter-rouge">1</code> represents black, and <code class="language-plaintext highlighter-rouge">0</code> represents white):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a      100011100010000
b      000000000110001
c      100000100010001
x      000001000100000
</code></pre></div></div>

<p>We have a one-letter answer whenever there’s a column with <code class="language-plaintext highlighter-rouge">101</code> in rows <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>, and <code class="language-plaintext highlighter-rouge">x</code>. In other words, if <code class="language-plaintext highlighter-rouge">b &amp; ~c &amp; x</code> has any ones (where <code class="language-plaintext highlighter-rouge">&amp;</code> is bitwise AND, and <code class="language-plaintext highlighter-rouge">~</code> is bitwise negation), then we’re in trouble. This means we must have <code class="language-plaintext highlighter-rouge">b &amp; ~c &amp; x == 0</code>, which I will slightly rewrite as <code class="language-plaintext highlighter-rouge">(b &amp; ~c) &amp; x == 0</code>. Similarly, we must have <code class="language-plaintext highlighter-rouge">(a &amp; ~b &amp; ~c) &amp; x == 0</code> to avoid any two-letter answers.</p>

<p>Awesome! So we can precompute a map <code class="language-plaintext highlighter-rouge">avoidOneOne</code> where <code class="language-plaintext highlighter-rouge">avoidOneOne[j]</code> stores every <code class="language-plaintext highlighter-rouge">k</code> satisfying <code class="language-plaintext highlighter-rouge">j &amp; k == 0</code> (i.e. <code class="language-plaintext highlighter-rouge">j</code> and <code class="language-plaintext highlighter-rouge">k</code> don’t have any <code class="language-plaintext highlighter-rouge">1</code> bits in the same position, hence the name). Therefore, <code class="language-plaintext highlighter-rouge">x</code> is simply the set of values in both <code class="language-plaintext highlighter-rouge">avoidOneOne[b &amp; ~c]</code> and <code class="language-plaintext highlighter-rouge">avoidOneOne[a &amp; ~b &amp; ~c]</code>.</p>

<p>If <code class="language-plaintext highlighter-rouge">avoidOneOne[j]</code> stored a list of <code class="language-plaintext highlighter-rouge">uint16</code> values for every <code class="language-plaintext highlighter-rouge">j</code>, we’d need to write some nontrivial logic to intersect the two lists. We can expedite this by storing bitarrays instead! Go has a <code class="language-plaintext highlighter-rouge">bitarray</code> <a href="https://godoc.org/github.com/golang-collections/go-datastructures/bitarray">package</a> that supports sparse bitarrays, so this was pretty easy to implement. There are only \(2^{16} = 65536\) possible <code class="language-plaintext highlighter-rouge">uint16</code> values, so each bitarray is 8.192 kilobytes in the worst case. No biggie.</p>

<p>Now, we can simply find all values of <code class="language-plaintext highlighter-rouge">x</code> by computing <code class="language-plaintext highlighter-rouge">avoidOneOne[b &amp; ~c].And(avoidOneOne[a &amp; ~b &amp; ~c]).ToNums()</code>, which intersects the two bitarrays and converts the result into a list of <code class="language-plaintext highlighter-rouge">uint16</code> values.</p>

<p>Note that we have to treat the last three rows carefully. Consider the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>d      100011100010000
e      000000000110001
f      100000100010001
EDGE   ---------------    
</code></pre></div></div>

<p>If there’s a column ending in <code class="language-plaintext highlighter-rouge">10</code> or <code class="language-plaintext highlighter-rouge">100</code>, then we violate the three-letter minimum. In other words, we must have <code class="language-plaintext highlighter-rouge">e &amp; ~f == 0</code> and <code class="language-plaintext highlighter-rouge">d &amp; ~e &amp; ~f == 0</code> . To deal with this, we ended up precomputing another map <code class="language-plaintext highlighter-rouge">avoidOneZero</code>, where <code class="language-plaintext highlighter-rouge">avoidOneZero[j]</code> stores a bitarray of all <code class="language-plaintext highlighter-rouge">k</code> satisfying <code class="language-plaintext highlighter-rouge">j &amp; ~k == 0</code>.</p>

<p>Here’s our hyper-optimized algorithm:</p>

<ol>
  <li>Precompute all valid rows.</li>
  <li>Precompute <code class="language-plaintext highlighter-rouge">reverse</code>, <code class="language-plaintext highlighter-rouge">avoidOneOne</code> and <code class="language-plaintext highlighter-rouge">avoidOneZero</code>.</li>
  <li>For every possible value of Row 8 (<code class="language-plaintext highlighter-rouge">r8</code>), consider values of <code class="language-plaintext highlighter-rouge">r7</code> satisfying <code class="language-plaintext highlighter-rouge">r7 &amp; ~r8 &amp; reverse[r7] == 0</code>. Can’t have a <code class="language-plaintext highlighter-rouge">101</code> in the middle three rows!</li>
  <li>Use <code class="language-plaintext highlighter-rouge">avoidOneOne</code> and <code class="language-plaintext highlighter-rouge">avoidOneZero</code> to compute the possibilities for the remaining rows.</li>
  <li>Turn candidate grids into a two-dimensional array and do the DFS check.</li>
  <li>Check special conditions.</li>
</ol>

<p>This helped a lot! We removed the \(O(n)\) check when evaluating rows, and the bithacks were wonderful. I don’t think we decreased the number of candidate grids, but we improved the constant factor significantly.</p>

<h3 id="take-5-final-touches">Take 5: Final Touches</h3>

<p>To top things off, we added a few more optimizations: first, Go made it easy to parallelize the search. Simply create <code class="language-plaintext highlighter-rouge">t</code> goroutines and assign each thread a subset of the middle rows.</p>

<p>Second, we also cared about the <em>number</em> of words in the grid. Most NYT crossword grids have around 60-80 words–more than that looks ugly, and fewer than that is essentially impossible to fill. As newbie constructors, we were looking at the 70-80 range. I won’t get into details, but we figured out an \(O(n)\) method to compute this value using bithacks and precomputation. This way, we’d eliminate a majority of grids before the DFS check. (Hint: In every row or column, a new word starts when we move from from an edge/black square to a white square.)</p>

<p>And that’s it! The program was spitting out hundreds of grids every minute, and we eventually found one that worked. You can check out <a href="https://github.com/akshayravikumar/crosswords">the source code</a>, but it’s quite a mess.</p>

<h3 id="the-end-of-the-story">The End of the Story</h3>

<p>So we filled up the grid, wrote clues, and submitted it to the New York Times. Unfortunately, it got rejected–it’s an extremely slow and competitive process!–but we submitted a revision and are awaiting feedback.</p>

<h2 id="theres-more">…there’s more?</h2>

<p>While working on this, I ran into a <a href="https://fivethirtyeight.com/features/how-many-crossword-puzzles-can-you-make/">FiveThirtyEight challenge</a> that asked how many valid 15x15 New York Times crossword grids you can make. Unfortunately, this program wasn’t going to cut it: there’s no point in generating every grid if you’re just trying to count them. I’ll talk about this in Part 2!</p>



      <a class="share" href="https://twitter.com/intent/tweet?text=&quot;Counting Crosswords, Part 1&quot;%20https://akshayr.me/blog//articles/counting-crosswords%20via%20&#64;" data-dnt="true">Share</a>
      <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

      
      <aside class="disqus">
        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'akshay-blog'; // required: replace example with your forum shortname

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </aside>
      

      </article>
    </section>
</div>

<div class="push"></div>
  <footer>
    <aside class="wrap">
      <ol class="prev-posts">
        <p class="list-title">Recent Posts</p>
         <!-- for1 -->
            <li>
              <span class="recent-title"><a href="http://localhost:4000/articles/counting-crosswords" title="Counting Crosswords, Part 1">Counting Crosswords, Part 1 </a></span>
              <span class="date">Jul 03, 2020</span>
            </li>
         <!-- for1 -->
            <li>
              <span class="recent-title"><a href="http://localhost:4000/articles/hello-world" title="Hello World">Hello World </a></span>
              <span class="date">Jul 02, 2020</span>
            </li>
        
      </ol>

      <div class="social">
        <ul>
            <li><a id="mail" href="mailto:akshay.ravikumar+blog@gmail.com"><span class="foot-link">Contact Me</span></a></li>

            


            
        </ul>
    </div>
    </aside>
    <small>&copy; 2020 Akshay Ravikumar. Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <a href="http://jekyll.gtat.me/about">Balzac</a> theme.</small>
  </footer>

  <!-- If they're out, get some from the cellar -->
  <script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
  <script src="http://localhost:4000/assets/js/retina.min.js"></script>

  <!-- Custom JS -->
  <script src="http://localhost:4000/assets/js/scripts.js"></script>


  </body>
</html>

